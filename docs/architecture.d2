title: "NIV Hexagonal Architecture - Perfect Symmetry Achieved" {
  near: top-center
}

# External Systems
client: Frontend/Client
pcc: PointClickCare EHR

# Primary Side (Inbound) - Perfect Hexagonal Architecture
controller: HTTP Controller {
  desc: "onboarding.controller.ts (HTTP Infrastructure)"
  note: "Maps HTTP ↔ Domain, Error handling"
}

service: NestJS Service {
  desc: "onboarding.service.ts (NestJS Framework Adapter)"
  note: "Logging, DI, Framework concerns"
}

primary_adapter: Primary Adapter {
  desc: "onboarding.ts (Framework-agnostic)"
  note: "Business operation coordination"
}

primary_ports: Primary Ports {
  shape: oval
  desc: "onboarding-operations.ts (Use Case Interfaces)"
  note: "GetPatientWithQualifications, TestPccConnection, etc."
}

# Domain Core (Hexagon Center)
domain: Domain Service {
  shape: hexagon
  desc: "qualifications.ts (Pure Business Logic)"
  note: "Framework-agnostic, Unit testable"
}

# Secondary Side (Outbound) - Perfect Hexagonal Architecture
secondary_ports: Secondary Ports {
  shape: oval
  desc: "ehr-operations.ts (Repository Interfaces)"
  note: "GetPatient, GetPatientDiagnoses, etc."
}

secondary_adapter: Secondary Adapter {
  desc: "ehr.ts (EHR Implementation)"
  note: "PCC implementation, Error mapping"
}

# Domain Objects
entities: Domain Objects {
  patient: "patient.ts (Entity)"
  diagnosis: "diagnosis.ts (Value Object)"
  errors: "errors.ts (Domain Errors)"
}

# Infrastructure
pcc_client: PCC Client {
  desc: "ehr/pcc/ (HTTP Infrastructure)"
  note: "mTLS, Token caching, Rate limiting"
}

# Primary Flow: Client → Domain → EHR (Now with perfect symmetry)
client -> controller: "1. HTTP Request"
controller -> service: "2. NestJS logging & DI"
service -> primary_adapter: "3. Framework-agnostic ops"
primary_adapter -> domain: "4. Business operation"
domain -> secondary_ports: "5. Need EHR data"
secondary_ports -> secondary_adapter: "6. Implementation"
secondary_adapter -> pcc_client: "7. HTTP call"
pcc_client -> pcc: "8. mTLS API"

# Response flow back (Perfect symmetry)
pcc -> pcc_client: "PCC JSON"
pcc_client -> secondary_adapter: "HTTP response"
secondary_adapter -> secondary_ports: "Domain objects"
secondary_ports -> domain: "Patient + Diagnoses"
domain -> primary_adapter: "Assessment result"
primary_adapter -> service: "Business outcome"
service -> controller: "NestJS response"
controller -> client: "HTTP response"

# Hexagonal Architecture Dependencies
primary_adapter -> primary_ports: "implements"
secondary_adapter -> secondary_ports: "implements"
domain -> entities: "Uses"
secondary_adapter -> entities: "Creates"

# Perfect Symmetry Annotation
symmetry: "Perfect Hexagonal Symmetry" {
  near: top-left

  primary_side: "Primary (Inbound): controller → service → primary_adapter → primary_ports"
  secondary_side: "Secondary (Outbound): secondary_ports → secondary_adapter → pcc_client"
  core: "Domain Service (Business Logic) at center"
  pattern: "Same *-operations.ts → *.ts pattern on both sides"
}

# Error Handling Flow - Infrastructure vs Business
pcc_error: "Infrastructure Error" {
  examples: "404, 503, 401, Timeout"
}

domain_error: "Domain Error" {
  properties: "code, action, context"
  actions: "'stop', 'retry', 'user-input'"
}

http_error: "HTTP Response" {
  properties: "status, structured JSON"
  mapping: "Action → HTTP Status"
}

business_outcome: "Business Outcome" {
  examples: "Empty diagnoses, Not eligible"
  format: "Success response"
}

# Error flow through layers
pcc -> pcc_error: {
  label: "API failure"
  style.stroke-dash: 5
}
pcc_error -> secondary_adapter: {
  label: "catch & map"
  style.stroke-dash: 5
}
secondary_adapter -> domain_error: {
  label: "mapPccErrorToOnboardingError()"
  style.stroke-dash: 5
}
domain_error -> primary_adapter: {
  label: "bubbles up (not caught)"
  style.stroke-dash: 5
}
primary_adapter -> service: {
  label: "bubbles up (not caught)"
  style.stroke-dash: 5
}
service -> controller: {
  label: "catch domain error"
  style.stroke-dash: 5
}
controller -> http_error: {
  label: "mapDomainErrorToHttp()"
  style.stroke-dash: 5
}
http_error -> client: {
  label: "503/404/422 + action"
  style.stroke-dash: 5
}

# Business outcome flow (not errors)
secondary_adapter -> business_outcome: {
  label: "404 diagnoses → []"
  style.stroke-dash: 3
}
business_outcome -> domain: {
  label: "success with data"
  style.stroke-dash: 3
}
domain -> primary_adapter: {
  label: "assessment result"
  style.stroke-dash: 3
}
primary_adapter -> controller: {
  label: "isNivEligible: false"
  style.stroke-dash: 3
}
controller -> client: {
  label: "200 + business result"
  style.stroke-dash: 3
}

# Architecture Benefits
benefits: "Architecture Benefits" {
  near: bottom-left

  framework_agnostic: "✅ Framework-agnostic primary adapter"
  unit_testable: "✅ Unit testable business logic"
  perfect_symmetry: "✅ Primary/Secondary symmetry"
  error_strategy: "✅ Infrastructure vs Business errors"
  healthcare_language: "✅ Healthcare ubiquitous language"
}

# Implementation Status
implementation: "Implementation Status" {
  near: bottom-right

  primary_ports: "✅ Primary port interfaces"
  primary_adapter: "✅ Framework-agnostic primary adapter"
  secondary_ports: "✅ EHR operation contracts"
  secondary_adapter: "✅ PCC implementation"
  domain_service: "✅ Pure domain service"
  error_classification: "✅ Action-based error handling"
  functional_ddd: "✅ Functional DDD pattern"
  perfect_hexagon: "✅ Perfect hexagonal architecture"
}

# Key Patterns
patterns: "Key Patterns Used" {
  near: top-right

  hexagonal: "Hexagonal Architecture"
  ddd: "Domain-Driven Design"
  functional: "Functional Programming"
  ubiquitous: "Healthcare Ubiquitous Language"
  error_actions: "Error Action Classification"
  ports_adapters: "Ports & Adapters Pattern"
  dependency_inversion: "Dependency Inversion Principle"
}

# Position elements for clarity in hexagonal pattern
client -> controller -> service -> primary_adapter -> domain -> secondary_ports -> secondary_adapter -> pcc_client -> pcc
