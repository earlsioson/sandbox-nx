# =============================================================================
# 3. APPLICATION SERVICES WITH PROPER PORTS (CORRECTED)
# File: 03-application-services.d2
# =============================================================================

vars: {
  d2-config: {
    layout-engine: tala
  }
}

# Application Services (Orchestration Layer)
application_services: Application Services {
  ProgramEnrollmentService: ProgramEnrollmentService {
    shape: class

    # Dependencies (Ports Only - No Concrete Implementations)
    dependencies: "Dependencies (Injected Ports):\n• ProgramEnrollmentRepositoryPort\n• PCCIntegrationPort\n• NotificationPort\n• NIVEligibilityService (Domain)"

    separator1: "──────────────────────────────"

    # Orchestration Methods
    createEnrollment: "+createEnrollment(command: CreateEnrollmentCommand): Promise<void>"
    qualifyPatient: "+qualifyPatient(command: QualifyPatientCommand): Promise<void>"
    updateEnrollmentStatus: "+updateEnrollmentStatus(command: UpdateStatusCommand): Promise<void>"
    processConsentResponse: "+processConsentResponse(command: ConsentResponseCommand): Promise<void>"
    activateProgram: "+activateProgram(command: ActivateProgramCommand): Promise<void>"

    separator2: "──────────────────────────────"

    # Private Orchestration Logic
    validateCommand: "-validateCommand(command: Command): void"
    publishIntegrationEvents: "-publishIntegrationEvents(events: DomainEvent[]): Promise<void>"

    note: "Orchestrates domain operations\nNo business logic here"
  }

  PatientSearchService: PatientSearchService {
    shape: class

    # Dependencies (Ports Only)
    dependencies: "Dependencies (Injected Ports):\n• PatientRepositoryPort\n• ProgramEnrollmentRepositoryPort\n• NotificationRepositoryPort"

    separator1: "──────────────────────────────"

    # Query Orchestration
    searchEnrollments: "+searchEnrollments(query: SearchEnrollmentsQuery): Promise<EnrollmentSearchResult[]>"
    findExistingPatients: "+findExistingPatients(query: FindPatientsQuery): Promise<Patient[]>"
    getEnrollmentsByFacility: "+getEnrollmentsByFacility(query: FacilityQuery): Promise<FacilityEnrollmentView[]>"
    countEnrollmentsByStatus: "+countEnrollmentsByStatus(query: StatusCountQuery): Promise<StatusCountResult>"

    separator2: "──────────────────────────────"

    # View Model Creation
    createSearchResultView: "-createSearchResultView(enrollments: Enrollment[], userRole: UserRole): EnrollmentSearchResult[]"
    applyRoleBasedFiltering: "-applyRoleBasedFiltering(results: SearchResult[], userRole: UserRole): SearchResult[]"

    note: "Query orchestration only\nView model transformation"
  }

  AuditTrailService: AuditTrailService {
    shape: class

    # Dependencies (Ports Only)
    dependencies: "Dependencies (Injected Ports):\n• AuditTrailRepositoryPort\n• DocumentStoragePort\n• UserAuthenticationPort"

    separator1: "──────────────────────────────"

    # Audit Operations
    getEnrollmentHistory: "+getEnrollmentHistory(query: AuditHistoryQuery): Promise<AuditTrailView[]>"
    generateAuditReport: "+generateAuditReport(command: GenerateAuditReportCommand): Promise<AuditReport>"
    trackUserAction: "+trackUserAction(command: TrackActionCommand): Promise<void>"
    getComplianceReport: "+getComplianceReport(query: ComplianceQuery): Promise<ComplianceReport>"

    separator2: "──────────────────────────────"

    # Report Generation
    createAuditDocument: "-createAuditDocument(entries: AuditTrailEntry[]): AuditDocument"
    validateReportPermissions: "-validateReportPermissions(userId: UserId, scope: ReportScope): void"

    note: "Audit orchestration\nCompliance reporting"
  }

  NotificationDisplayService: NotificationDisplayService {
    shape: class

    # Dependencies (Ports Only)
    dependencies: "Dependencies (Injected Ports):\n• NotificationRepositoryPort\n• UserPreferencesPort"

    separator1: "──────────────────────────────"

    # Notification Queries
    getNotificationsByRole: "+getNotificationsByRole(query: RoleNotificationQuery): Promise<RoleNotificationView[]>"
    getNotificationSummary: "+getNotificationSummary(query: NotificationSummaryQuery): Promise<NotificationSummary>"
    markNotificationsAsRead: "+markNotificationsAsRead(command: MarkReadCommand): Promise<void>"
    getUserNotificationPreferences: "+getUserNotificationPreferences(userId: UserId): Promise<NotificationPreferences>"

    separator2: "──────────────────────────────"

    # View Transformation
    createRoleBasedView: "-createRoleBasedView(notifications: Notification[], role: UserRole): RoleNotificationView[]"
    aggregateNotificationCounts: "-aggregateNotificationCounts(notifications: Notification[]): NotificationSummary"

    note: "Notification view logic\nRole-based presentation"
  }
}

# Port Interfaces (Abstract Contracts)
repository_ports: Repository Ports {
  ProgramEnrollmentRepositoryPort: ProgramEnrollmentRepositoryPort {
    shape: interface

    # Repository Contract (No Implementation)
    save: "+save(enrollment: ProgramEnrollment): Promise<void>"
    findById: "+findById(id: EnrollmentId): Promise<ProgramEnrollment>"
    findByPatient: "+findByPatient(patientId: PatientId): Promise<ProgramEnrollment[]>"
    findByFacility: "+findByFacility(facilityId: FacilityId): Promise<ProgramEnrollment[]>"
    findByStatus: "+findByStatus(status: EnrollmentStatusType): Promise<ProgramEnrollment[]>"
    findByCriteria: "+findByCriteria(criteria: EnrollmentSearchCriteria): Promise<ProgramEnrollment[]>"
    countByStatus: "+countByStatus(): Promise<Map<EnrollmentStatusType, number>>"

    note: "Abstract repository contract\nNo persistence details"
  }

  PatientRepositoryPort: PatientRepositoryPort {
    shape: interface

    # Patient Repository Contract
    save: "+save(patient: Patient): Promise<void>"
    findById: "+findById(id: PatientId): Promise<Patient>"
    findByMedicalRecord: "+findByMedicalRecord(recordNumber: MedicalRecordNumber): Promise<Patient>"
    findByPCCId: "+findByPCCId(pccId: PCCPatientId): Promise<Patient>"
    searchByCriteria: "+searchByCriteria(criteria: PatientSearchCriteria): Promise<Patient[]>"

    note: "Abstract patient contract\nNo storage implementation"
  }

  AuditTrailRepositoryPort: AuditTrailRepositoryPort {
    shape: interface

    # Audit Repository Contract
    save: "+save(entry: AuditTrailEntry): Promise<void>"
    findByEnrollment: "+findByEnrollment(enrollmentId: EnrollmentId): Promise<AuditTrailEntry[]>"
    findByDateRange: "+findByDateRange(start: Date, end: Date): Promise<AuditTrailEntry[]>"
    findByUser: "+findByUser(userId: UserId): Promise<AuditTrailEntry[]>"
    findByAction: "+findByAction(action: AuditAction): Promise<AuditTrailEntry[]>"

    note: "Abstract audit contract\nNo storage specifics"
  }
}

integration_ports: Integration Ports {
  PCCIntegrationPort: PCCIntegrationPort {
    shape: interface

    # PCC Integration Contract
    getPatientData: "+getPatientData(patientId: PatientId): Promise<EHRData>"
    refreshPatientData: "+refreshPatientData(patientId: PatientId): Promise<EHRData>"
    getLabResults: "+getLabResults(patientId: PatientId): Promise<LabResult[]>"
    getDiagnosisCodes: "+getDiagnosisCodes(patientId: PatientId): Promise<DiagnosisCode[]>"
    subscribeToUpdates: "+subscribeToUpdates(patientId: PatientId): Promise<void>"

    note: "Abstract PCC contract\nNo API implementation details"
  }

  NotificationPort: NotificationPort {
    shape: interface

    # Notification Contract
    sendEmail: "+sendEmail(recipient: EmailAddress, message: EmailMessage): Promise<void>"
    sendSMS: "+sendSMS(recipient: PhoneNumber, message: SMSMessage): Promise<void>"
    sendPushNotification: "+sendPushNotification(userId: UserId, message: PushMessage): Promise<void>"
    sendRoleBasedNotifications: "+sendRoleBasedNotifications(enrollment: ProgramEnrollment, eventType: NotificationEventType): Promise<void>"

    note: "Abstract notification contract\nNo delivery implementation"
  }

  DocumentStoragePort: DocumentStoragePort {
    shape: interface

    # Document Storage Contract
    store: "+store(document: Document): Promise<DocumentId>"
    retrieve: "+retrieve(documentId: DocumentId): Promise<Document>"
    generateDownloadUrl: "+generateDownloadUrl(documentId: DocumentId): Promise<string>"
    delete: "+delete(documentId: DocumentId): Promise<void>"
    listByEnrollment: "+listByEnrollment(enrollmentId: EnrollmentId): Promise<DocumentMetadata[]>"

    note: "Abstract storage contract\nNo storage provider details"
  }
}

# Command and Query Objects (CQRS-lite)
commands_queries: Commands & Queries {
  CreateEnrollmentCommand: CreateEnrollmentCommand {
    shape: class

    patientId: "+patientId: PatientId"
    programType: "+programType: ProgramType"
    facilityId: "+facilityId: FacilityId"
    initiatedBy: "+initiatedBy: UserId"

    note: "Command object\nValidation included"
  }

  SearchEnrollmentsQuery: SearchEnrollmentsQuery {
    shape: class

    facilityId: "+facilityId?: FacilityId"
    status: "+status?: EnrollmentStatusType"
    assignedSpecialist: "+assignedSpecialist?: UserId"
    userRole: "+userRole: UserRole"
    pagination: "+pagination: PaginationInfo"

    note: "Query object\nRole-based filtering"
  }

  EnrollmentSearchResult: EnrollmentSearchResult {
    shape: class

    enrollmentId: "+enrollmentId: EnrollmentId"
    patientName: "+patientName: string"
    status: "+status: EnrollmentStatusType"
    progress: "+progress: EnrollmentProgress"
    notifications: "+notifications: NotificationSummary"
    canEdit: "+canEdit: boolean"
    canView: "+canView: boolean"

    note: "View model\nRole-specific permissions"
  }
}

# Domain Services (Injected into Application Services)
domain_services: Domain Services {
  NIVEligibilityService: NIVEligibilityService {
    shape: class

    # Pure Business Logic (No External Dependencies)
    assessEligibility: "+assessEligibility(patient: Patient, labResults: LabResult[], diagnosisCodes: DiagnosisCode[]): EligibilityAssessment"
    generateClinicalReasoning: "+generateClinicalReasoning(...): string"
    determineRequiredLabs: "+determineRequiredLabs(...): LabRequirement[]"

    note: "Domain service\nPure business logic"
  }

  SpecialistAssignmentService: SpecialistAssignmentService {
    shape: class

    # Business Assignment Logic
    assignOptimalSpecialist: "+assignOptimalSpecialist(patient: Patient, programType: ProgramType, facilityId: FacilityId): ClinicalSpecialist"
    balanceWorkload: "+balanceWorkload(specialists: ClinicalSpecialist[]): ClinicalSpecialist[]"

    note: "Domain service\nAssignment logic only"
  }
}

# Dependencies (All pointing to abstractions)
application_services.ProgramEnrollmentService -> repository_ports.ProgramEnrollmentRepositoryPort: "depends on"
application_services.ProgramEnrollmentService -> integration_ports.PCCIntegrationPort: "depends on"
application_services.ProgramEnrollmentService -> integration_ports.NotificationPort: "depends on"
application_services.ProgramEnrollmentService -> domain_services.NIVEligibilityService: "uses"

application_services.PatientSearchService -> repository_ports.PatientRepositoryPort: "depends on"
application_services.PatientSearchService -> repository_ports.ProgramEnrollmentRepositoryPort: "depends on"

application_services.AuditTrailService -> repository_ports.AuditTrailRepositoryPort: "depends on"
application_services.AuditTrailService -> integration_ports.DocumentStoragePort: "depends on"

application_services.NotificationDisplayService -> repository_ports.PatientRepositoryPort: "depends on"

# Command/Query Flow
commands_queries.CreateEnrollmentCommand -> application_services.ProgramEnrollmentService: "processed by"
commands_queries.SearchEnrollmentsQuery -> application_services.PatientSearchService: "handled by"
application_services.PatientSearchService -> commands_queries.EnrollmentSearchResult: "returns"
