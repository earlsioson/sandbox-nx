# =============================================================================
# 5. UX TO DOMAIN MAPPING (CORRECTED FLOW)
# File: 05-ux-domain-mapping.d2
# =============================================================================

vars: {
  d2-config: {
    layout-engine: tala
  }
}

direction: right

# UX Layer (Presenters/Controllers)
ux_layer: UX Layer (Controllers) {
  PatientSearchController: PatientSearchController {
    endpoints: "REST Endpoints:\n• GET /api/onboardings/search\n• GET /api/patients/search\n• GET /api/onboardings/facility/{id}"

    searchOnboardings: "+searchOnboardings(query: SearchOnboardingsRequest): Promise<OnboardingSearchResult[]>"
    searchPatients: "+searchPatients(query: PatientSearchRequest): Promise<PatientSearchResult[]>"
    getOnboardingsByFacility: "+getOnboardingsByFacility(facilityId: string, userRole: UserRole): Promise<FacilityOnboardingView[]>"

    note: "HTTP entry point\nRequest/Response transformation only"
  }

  ProgramOnboardingController: ProgramOnboardingController {
    endpoints: "REST Endpoints:\n• POST /api/onboardings\n• PUT /api/onboardings/{id}/qualify\n• PUT /api/onboardings/{id}/consent\n• PUT /api/onboardings/{id}/activate"

    createOnboarding: "+createOnboarding(request: CreateOnboardingRequest): Promise<OnboardingResponse>"
    qualifyPatient: "+qualifyPatient(id: string, request: QualifyPatientRequest): Promise<QualificationResponse>"
    processConsent: "+processConsent(id: string, request: ConsentRequest): Promise<ConsentResponse>"
    activateProgram: "+activateProgram(id: string): Promise<ActivationResponse>"

    note: "Onboarding operations\nCommand handling entry point"
  }

  AuditTrailController: AuditTrailController {
    endpoints: "REST Endpoints:\n• GET /api/audit/onboarding/{id}\n• POST /api/audit/report\n• GET /api/audit/documents/{onboardingId}"

    getOnboardingHistory: "+getOnboardingHistory(onboardingId: string, userRole: UserRole): Promise<AuditTrailView[]>"
    generateAuditReport: "+generateAuditReport(request: AuditReportRequest): Promise<AuditReportResponse>"
    getUploadedDocuments: "+getUploadedDocuments(onboardingId: string): Promise<DocumentListView[]>"

    note: "Audit operations\nCompliance reporting"
  }

  NotificationController: NotificationController {
    endpoints: "REST Endpoints:\n• GET /api/notifications/role/{role}\n• GET /api/notifications/summary\n• PUT /api/notifications/mark-read"

    getNotificationsByRole: "+getNotificationsByRole(role: UserRole): Promise<RoleNotificationView[]>"
    getNotificationSummary: "+getNotificationSummary(userId: string): Promise<NotificationSummary>"
    markAsRead: "+markAsRead(notificationIds: string[]): Promise<void>"

    note: "Notification queries\nRole-based views"
  }

  WebhookController: WebhookController {
    endpoints: "Webhook Endpoints:\n• POST /api/webhooks/pcc/patient-updated\n• POST /api/webhooks/platform/patient-admitted"

    handlePCCPatientUpdate: "+handlePCCPatientUpdate(payload: PCCWebhookPayload): Promise<void>"
    handlePatientAdmission: "+handlePatientAdmission(payload: AdmissionWebhookPayload): Promise<void>"

    note: "External event handling\nWebhook integrations"
  }
}

# Application Layer (Orchestration Services)
application_layer: Application Layer (Services) {
  PatientSearchService: PatientSearchService {
    # Query Orchestration Methods
    searchOnboardings: "+searchOnboardings(query: SearchOnboardingsQuery): Promise<OnboardingSearchResult[]>"
    searchPatients: "+searchPatients(query: SearchPatientsQuery): Promise<PatientSearchResult[]>"
    getOnboardingsByFacility: "+getOnboardingsByFacility(query: FacilityOnboardingsQuery): Promise<FacilityOnboardingView[]>"

    separator1: "──────────────────────────────"

    # View Model Creation (No Business Logic)
    createOnboardingSearchResults: "-createOnboardingSearchResults(onboardings: ProgramOnboarding[], userRole: UserRole): OnboardingSearchResult[]"
    applyRoleBasedFiltering: "-applyRoleBasedFiltering(results: SearchResult[], userRole: UserRole): SearchResult[]"
    aggregateNotificationData: "-aggregateNotificationData(onboardings: ProgramOnboarding[]): NotificationSummary"

    note: "Query orchestration only\nView model transformation"
  }

  ProgramOnboardingService: ProgramOnboardingService {
    # Command Orchestration Methods
    createOnboarding: "+createOnboarding(command: CreateOnboardingCommand): Promise<OnboardingId>"
    qualifyPatient: "+qualifyPatient(command: QualifyPatientCommand): Promise<void>"
    processConsentResponse: "+processConsentResponse(command: ConsentResponseCommand): Promise<void>"
    activateProgram: "+activateProgram(command: ActivateProgramCommand): Promise<void>"

    separator2: "──────────────────────────────"

    # Orchestration Logic (No Business Rules)
    validateCommand: "-validateCommand(command: Command): ValidationResult"
    publishDomainEvents: "-publishDomainEvents(events: DomainEvent[]): Promise<void>"
    sendIntegrationEvents: "-sendIntegrationEvents(events: IntegrationEvent[]): Promise<void>"

    note: "Command orchestration only\nNo business logic here"
  }

  AuditTrailService: AuditTrailService {
    # Audit Query Methods
    getOnboardingHistory: "+getOnboardingHistory(query: OnboardingHistoryQuery): Promise<AuditTrailView[]>"
    generateAuditReport: "+generateAuditReport(command: GenerateAuditReportCommand): Promise<AuditReport>"
    trackUserAction: "+trackUserAction(command: TrackActionCommand): Promise<void>"

    separator3: "──────────────────────────────"

    # Report Generation (Data Assembly)
    assembleAuditData: "-assembleAuditData(criteria: AuditCriteria): AuditData"
    createAuditDocument: "-createAuditDocument(auditData: AuditData): AuditDocument"
    validateReportPermissions: "-validateReportPermissions(userId: UserId, scope: ReportScope): void"

    note: "Audit data orchestration\nCompliance reporting"
  }

  NotificationDisplayService: NotificationDisplayService {
    # Notification Query Methods
    getNotificationsByRole: "+getNotificationsByRole(query: RoleNotificationQuery): Promise<RoleNotificationView[]>"
    getNotificationSummary: "+getNotificationSummary(query: NotificationSummaryQuery): Promise<NotificationSummary>"
    markNotificationsAsRead: "+markNotificationsAsRead(command: MarkReadCommand): Promise<void>"

    separator4: "──────────────────────────────"

    # View Assembly (No Business Logic)
    createRoleBasedView: "-createRoleBasedView(notifications: Notification[], role: UserRole): RoleNotificationView[]"
    aggregateNotificationCounts: "-aggregateNotificationCounts(notifications: Notification[]): NotificationSummary"
    filterByPermissions: "-filterByPermissions(notifications: Notification[], userRole: UserRole): Notification[]"

    note: "Notification view assembly\nRole-based presentation"
  }
}

# Domain Layer (Pure Business Logic)
domain_layer: Domain Layer (Business Logic) {
  NIVProgramOnboarding: NIVProgramOnboarding {
    # Rich Business Behavior
    makeQualificationDecision: "+makeQualificationDecision(decision: QualificationDecision, assessedBy: UserId): void"
    processConsentResponse: "+processConsentResponse(consentGiven: boolean, reason?: string): void"
    assessAdditionalLabsRequired: "+assessAdditionalLabsRequired(reasoning: string, assessedBy: UserId): void"
    scheduleDeviceFitting: "+scheduleDeviceFitting(fittingDate: Date): void"
    activateProgram: "+activateProgram(): void"

    separator1: "──────────────────────────────"

    # Business State Queries
    isQualified: "+isQualified(): boolean"
    canActivate: "+canActivate(): boolean"
    requiresAdditionalLabs: "+requiresAdditionalLabs(): boolean"
    getProgress: "+getProgress(): OnboardingProgress"
    getNextRequiredAction: "+getNextRequiredAction(): RequiredAction"

    note: "NIV business logic\nWorkflow state management"
  }

  Patient: Patient {
    # Patient Business Logic
    isEligibleForNIV: "+isEligibleForNIV(criteria: NIVCriteria): boolean"
    enrollInProgram: "+enrollInProgram(programType: ProgramType, specialist: ClinicalSpecialist): ProgramOnboarding"
    validateMedicalRequirements: "+validateMedicalRequirements(programType: ProgramType): ValidationResult"
    updateDemographics: "+updateDemographics(demographics: PatientDemographics): void"

    separator2: "──────────────────────────────"

    # Patient State Queries
    isValidForOnboarding: "+isValidForProgramOnboarding(): boolean"
    getFullName: "+getFullName(): string"
    hasActiveOnboardings: "+hasActiveOnboardings(): boolean"
    getMedicalHistory: "+getMedicalHistory(): MedicalHistory"

    note: "Patient business logic\nEligibility validation"
  }

  NIVEligibilityService: NIVEligibilityService {
    # Complex Business Logic
    assessEligibility: "+assessEligibility(patient: Patient, labResults: LabResult[], diagnosisCodes: DiagnosisCode[]): EligibilityAssessment"
    generateClinicalReasoning: "+generateClinicalReasoning(assessment: EligibilityAssessment): string"
    determineRequiredLabs: "+determineRequiredLabs(currentLabs: LabResult[]): LabRequirement[]"

    separator3: "──────────────────────────────"

    # Private Business Rules
    checkRespiratoryConditions: "-checkRespiratoryConditions(diagnosisCodes: DiagnosisCode[]): boolean"
    assessLabResults: "-assessLabResults(labResults: LabResult[]): boolean"
    evaluateRiskFactors: "-evaluateRiskFactors(patient: Patient): RiskAssessment"

    note: "Complex eligibility rules\nClinical decision logic"
  }

  SpecialistAssignmentService: SpecialistAssignmentService {
    # Assignment Business Logic
    assignOptimalSpecialist: "+assignOptimalSpecialist(patient: Patient, programType: ProgramType, facilityId: FacilityId): ClinicalSpecialist"
    balanceWorkload: "+balanceWorkload(specialists: ClinicalSpecialist[]): ClinicalSpecialist[]"
    matchExpertise: "+matchExpertise(specialists: ClinicalSpecialist[], programType: ProgramType): ClinicalSpecialist[]"

    note: "Assignment optimization\nWorkload balancing logic"
  }

  # Value Objects (Immutable Business Concepts)
  OnboardingProgress: OnboardingProgress {
    getCompletionPercentage: "+getCompletionPercentage(): number"
    getNextRequiredStep: "+getNextRequiredStep(): ProgressStep"
    isComplete: "+isComplete(): boolean"
    getEstimatedCompletion: "+getEstimatedCompletionDate(): Date"

    note: "Progress calculation\nBusiness-driven milestones"
  }

  NotificationSummary: NotificationSummary {
    getCountForRole: "+getCountForRole(role: UserRole): number"
    hasNotificationsForRole: "+hasNotificationsForRole(role: UserRole): boolean"
    getTotalUnreadCount: "+getTotalUnreadCount(): number"
    hasUrgentNotifications: "+hasUrgentNotifications(): boolean"

    note: "Notification aggregation\nRole-based business rules"
  }
}

# Request/Response Flow (UX → Application → Domain)
ux_layer.PatientSearchController -> application_layer.PatientSearchService: "delegates to"
ux_layer.ProgramOnboardingController -> application_layer.ProgramOnboardingService: "delegates to"
ux_layer.AuditTrailController -> application_layer.AuditTrailService: "delegates to"
ux_layer.NotificationController -> application_layer.NotificationDisplayService: "delegates to"

# Application Service → Domain Logic Flow
application_layer.ProgramOnboardingService -> domain_layer.NIVProgramOnboarding: "orchestrates business operations"
application_layer.ProgramOnboardingService -> domain_layer.Patient: "validates and enrolls"
application_layer.ProgramOnboardingService -> domain_layer.NIVEligibilityService: "uses for assessment"
application_layer.ProgramOnboardingService -> domain_layer.SpecialistAssignmentService: "uses for assignment"

application_layer.PatientSearchService -> domain_layer.OnboardingProgress: "calculates progress"
application_layer.NotificationDisplayService -> domain_layer.NotificationSummary: "aggregates notifications"

# UX Component Mapping to Domain Capabilities
ux_layer.PatientSearchController.components: "onboardLanding.searchPatient\nonboardLanding.searchResults\ncreatePatient.searchPatient"
ux_layer.PatientSearchController -> domain_layer.Patient: "Patient search & validation"

ux_layer.ProgramOnboardingController.components: "createAdmission.confirm\nresidentDetailsV2.onBoardingProgress"
ux_layer.ProgramOnboardingController -> domain_layer.NIVProgramOnboarding: "Onboarding workflow"

ux_layer.AuditTrailController.components: "residentDetailsV2.header.viewHistory\nresidentDetailsV2.header.downloadAudit"
ux_layer.AuditTrailController -> domain_layer.NIVProgramOnboarding: "Audit trail access"

ux_layer.NotificationController.components: "notifications columns\nrole-based notifications"
ux_layer.NotificationController -> domain_layer.NotificationSummary: "Notification aggregation"

# Data Flow Direction (All Dependencies Point Inward)
note_dependency_flow: "CRITICAL: All dependencies flow inward\nUX → Application → Domain\nDomain has ZERO external dependencies"
