# =============================================================================
# 2. DOMAIN MODEL RELATIONSHIPS
# File: 02-domain-model.d2
# =============================================================================

vars: {
  d2-config: {
    layout-engine: tala
  }
}

# Rich Domain Entities (Not Anemic)
entities: Rich Domain Entities {
  Patient: Patient {
    shape: class

    # Entity Identity
    patientId: "+patientId: PatientId"

    # Entity Properties  
    demographics: "-demographics: PatientDemographics"
    medicalRecord: "-medicalRecord: MedicalRecordNumber"
    medicalHistory: "-medicalHistory: MedicalHistory"
    facilityAssignment: "-facilityAssignment: FacilityId"

    separator1: "──────────────────────────────"

    # Rich Business Behavior (NOT Anemic)
    getFullName: "+getFullName(): string"
    isValidForEnrollment: "+isValidForProgramEnrollment(): boolean"
    isEligibleForNIV: "+isEligibleForNIV(criteria: NIVCriteria): boolean"
    updateDemographics: "+updateDemographics(demographics: PatientDemographics): void"
    enrollInProgram: "+enrollInProgram(programType: ProgramType): ProgramEnrollment"
    validateMedicalRequirements: "+validateMedicalRequirements(): ValidationResult"

    note: "Rich Entity with Business Logic\nNOT just data holder"
  }

  ProgramEnrollment: ProgramEnrollment {
    shape: class
    label: "<<Aggregate Root>> ProgramEnrollment"

    # Aggregate Root Identity
    enrollmentId: "-enrollmentId: EnrollmentId"

    # Aggregate State
    patient: "-patient: Patient"
    programType: "-programType: ProgramType"
    enrollmentStatus: "-enrollmentStatus: EnrollmentStatus"
    assignedSpecialist: "-assignedSpecialist: ClinicalSpecialist"
    auditTrail: "-auditTrail: AuditTrailEntry[]"
    documents: "-documents: DocumentMetadata[]"
    domainEvents: "-domainEvents: DomainEvent[]"

    separator2: "──────────────────────────────"

    # Aggregate Business Operations
    transitionStatus: "+transitionStatus(newStatus: EnrollmentStatusType, reason: string): void"
    addAuditEntry: "+addAuditEntry(action: AuditAction, performedBy: UserId): void"
    attachDocument: "+attachDocument(document: DocumentMetadata): void"
    assignSpecialist: "+assignSpecialist(specialist: ClinicalSpecialist): void"
    getProgress: "+getProgress(): EnrollmentProgress"
    canTransitionTo: "+canTransitionTo(status: EnrollmentStatusType): boolean"
    makeQualificationDecision: "+makeQualificationDecision(decision: QualificationDecision): void"
    processConsentResponse: "+processConsentResponse(consent: ConsentResponse): void"
    getDomainEvents: "+getDomainEvents(): DomainEvent[]"
    clearDomainEvents: "+clearDomainEvents(): void"

    note: "Aggregate Root\nConsistency boundary"
  }

  NIVProgramEnrollment: NIVProgramEnrollment {
    shape: class
    label: "<<NIV Aggregate Root>> NIVProgramEnrollment"

    # NIV-Specific Properties
    qualificationAssessment: "-qualificationAssessment: NIVQualificationAssessment"
    deviceConfiguration: "-deviceConfiguration: NIVDeviceConfiguration"

    separator1: "──────────────────────────────"

    # NIV-Specific Business Operations
    assessEligibility: "+assessEligibility(criteria: NIVCriteria): EligibilityAssessment"
    scheduleDeviceFitting: "+scheduleDeviceFitting(fittingDate: Date): void"
    activateProgram: "+activateProgram(): void"
    orderAdditionalLabs: "+orderAdditionalLabs(requirements: LabRequirement[]): void"
    disqualifyPatient: "+disqualifyPatient(reason: DisqualificationReason): void"
    returnToAssessment: "+returnToAssessment(): void"

    note: "NIV-specific aggregate\nExtends ProgramEnrollment"
  }

  AuditTrailEntry: AuditTrailEntry {
    shape: class

    # Audit Properties
    id: "+id: AuditEntryId"
    action: "+action: AuditAction"
    performedBy: "+performedBy: UserId"
    timestamp: "+timestamp: Date"
    details: "+details: AuditDetails"
    previousValue: "+previousValue: any"
    newValue: "+newValue: any"

    separator1: "──────────────────────────────"

    # Audit Operations
    isSignificantChange: "+isSignificantChange(): boolean"
    getDescription: "+getDescription(): string"
    toComplianceRecord: "+toComplianceRecord(): ComplianceAuditRecord"

    note: "Entity within aggregate\nCompliance tracking"
  }

  ClinicalSpecialist: ClinicalSpecialist {
    shape: class

    # Specialist Identity
    specialistId: "+specialistId: SpecialistId"
    credentials: "+credentials: Credentials"
    specializations: "+specializations: Specialization[]"
    facilityAssignments: "+facilityAssignments: FacilityId[]"
    workloadCapacity: "+workloadCapacity: WorkloadCapacity"

    separator1: "──────────────────────────────"

    # Specialist Business Behavior
    isAvailableForAssignment: "+isAvailableForAssignment(): boolean"
    hasExpertiseFor: "+hasExpertiseFor(programType: ProgramType): boolean"
    getCurrentWorkload: "+getCurrentWorkload(): number"
    canHandleAdditionalPatient: "+canHandleAdditionalPatient(): boolean"

    note: "RT and other specialists\nWorkload management"
  }
}

# Domain Factories (Enhanced - Encapsulate Complex Creation)
factories: Domain Factories {
  NIVProgramEnrollmentFactory: NIVProgramEnrollmentFactory {
    shape: class

    # Dependencies
    dependencies: "Dependencies:\n• NIVEligibilityService\n• SpecialistAssignmentService\n• AuditTrailService"

    separator1: "──────────────────────────────"

    # Factory Methods for Different Creation Scenarios
    createFromPatientAdmission: "+createFromPatientAdmission(patient: Patient, admissionEvent: AdmissionEvent, facilityId: FacilityId): NIVProgramEnrollment"
    createFromManualAssessment: "+createFromManualAssessment(patient: Patient, requestingRT: ClinicalSpecialist, facilityId: FacilityId): NIVProgramEnrollment"
    createFromPlatformEvent: "+createFromPlatformEvent(patientId: PatientId, platformEvent: PlatformAdmissionEvent): NIVProgramEnrollment"
    createFromEHRTrigger: "+createFromEHRTrigger(patientId: PatientId, ehrEvent: EHREvent): NIVProgramEnrollment"

    separator2: "──────────────────────────────"

    # Private Creation Logic
    validatePatientForNIV: "-validatePatientForNIV(patient: Patient): void"
    assignOptimalSpecialist: "-assignOptimalSpecialist(patient: Patient, facilityId: FacilityId): ClinicalSpecialist"
    initializeAuditTrail: "-initializeAuditTrail(createdBy: UserId, source: CreationSource): AuditTrailEntry"
    setupInitialNotifications: "-setupInitialNotifications(enrollment: NIVProgramEnrollment): void"

    note: "Encapsulates complex creation logic\nHandles multiple creation scenarios\nEnsures proper initialization"
  }

  PatientFactory: PatientFactory {
    shape: class

    # Patient Creation Methods
    createFromEHRData: "+createFromEHRData(ehrData: EHRPatientData): Patient"
    createFromAdmissionData: "+createFromAdmissionData(admissionData: AdmissionData): Patient"
    createFromManualEntry: "+createFromManualEntry(patientData: PatientRegistrationData): Patient"

    # Private Validation
    validatePatientData: "-validatePatientData(data: any): ValidationResult"
    enrichWithDefaults: "-enrichWithDefaults(patient: Patient): Patient"

    note: "Patient creation and validation\nData enrichment and defaults"
  }

  QualificationAssessmentFactory: QualificationAssessmentFactory {
    shape: class

    # Assessment Creation
    createInitialAssessment: "+createInitialAssessment(patient: Patient, ehrData: EHRData): NIVQualificationAssessment"
    createFromReassessment: "+createFromReassessment(previousAssessment: NIVQualificationAssessment, newData: ClinicalData): NIVQualificationAssessment"

    # Assessment Logic
    gatherRequiredData: "-gatherRequiredData(patient: Patient): ClinicalDataSet"
    validateAssessmentData: "-validateAssessmentData(data: ClinicalDataSet): void"

    note: "Assessment creation and validation\nClinical data gathering"
  }
}

# Value Objects (Immutable Business Concepts)
value_objects: Value Objects {
  EnrollmentStatus: EnrollmentStatus {
    shape: class
    label: "<<Value Object>> EnrollmentStatus"

    # Status Properties
    statusType: "+readonly statusType: EnrollmentStatusType"
    transitionDate: "+readonly transitionDate: Date"
    reason: "+readonly reason: string"
    validTransitions: "+readonly validTransitions: EnrollmentStatusType[]"

    separator1: "──────────────────────────────"

    # Status Operations
    canTransitionTo: "+canTransitionTo(newStatus: EnrollmentStatusType): boolean"
    createTransition: "+createTransition(newStatus: EnrollmentStatusType, reason: string): EnrollmentStatus"
    isActive: "+isActive(): boolean"
    requiresAction: "+requiresAction(): boolean"
    getDisplayText: "+getDisplayText(): string"
    equals: "+equals(other: EnrollmentStatus): boolean"

    note: "Immutable status with\nbusiness validation"
  }

  EnrollmentProgress: EnrollmentProgress {
    shape: class
    label: "<<Value Object>> EnrollmentProgress"

    # Progress Properties
    completedSteps: "+readonly completedSteps: ProgressStep[]"
    currentStep: "+readonly currentStep: ProgressStep"
    totalSteps: "+readonly totalSteps: number"

    separator2: "──────────────────────────────"

    # Progress Calculations
    getCompletionPercentage: "+getCompletionPercentage(): number"
    getNextRequiredStep: "+getNextRequiredStep(): ProgressStep"
    isComplete: "+isComplete(): boolean"
    getEstimatedCompletionDate: "+getEstimatedCompletionDate(): Date"
    equals: "+equals(other: EnrollmentProgress): boolean"

    note: "Calculated progress\nwith business rules"
  }

  PatientDemographics: PatientDemographics {
    shape: class
    label: "<<Value Object>> PatientDemographics"

    # Demographic Data
    firstName: "+readonly firstName: string"
    lastName: "+readonly lastName: string"
    dateOfBirth: "+readonly dateOfBirth: Date"
    gender: "+readonly gender: Gender"

    separator3: "──────────────────────────────"

    # Demographic Operations
    getFullName: "+getFullName(): string"
    getAge: "+getAge(): number"
    isMinor: "+isMinor(): boolean"
    equals: "+equals(other: PatientDemographics): boolean"

    note: "Immutable demographics\nwith derived calculations"
  }

  NotificationSummary: NotificationSummary {
    shape: class
    label: "<<Value Object>> NotificationSummary"

    # Notification Counts
    totalCount: "+readonly totalCount: number"
    unreadCount: "+readonly unreadCount: number"
    urgentCount: "+readonly urgentCount: number"
    roleCounts: "+readonly roleCounts: Map<UserRole, number>"

    separator4: "──────────────────────────────"

    # Notification Queries
    getCountForRole: "+getCountForRole(role: UserRole): number"
    hasNotificationsForRole: "+hasNotificationsForRole(role: UserRole): boolean"
    getTotalUnreadCount: "+getTotalUnreadCount(): number"
    hasUrgentNotifications: "+hasUrgentNotifications(): boolean"
    equals: "+equals(other: NotificationSummary): boolean"

    note: "Read-only notification\naggregation"
  }
}

# Domain Services (Complex Business Logic)
domain_services: Domain Services {
  NIVEligibilityService: NIVEligibilityService {
    shape: class

    # Complex Business Logic
    assessEligibility: "+assessEligibility(patient: Patient, labResults: LabResult[], diagnosisCodes: DiagnosisCode[]): EligibilityAssessment"
    generateClinicalReasoning: "+generateClinicalReasoning(assessment: EligibilityAssessment): string"
    determineRequiredLabs: "+determineRequiredLabs(currentLabs: LabResult[]): LabRequirement[]"

    separator1: "──────────────────────────────"

    # Private Business Rules
    checkRespiratoryConditions: "-checkRespiratoryConditions(diagnosisCodes: DiagnosisCode[]): boolean"
    assessLabResults: "-assessLabResults(labResults: LabResult[]): boolean"
    evaluateRiskFactors: "-evaluateRiskFactors(patient: Patient): RiskAssessment"

    note: "Complex eligibility logic\nNo external dependencies"
  }

  SpecialistAssignmentService: SpecialistAssignmentService {
    shape: class

    # Assignment Logic
    assignOptimalSpecialist: "+assignOptimalSpecialist(patient: Patient, programType: ProgramType, facilityId: FacilityId): ClinicalSpecialist"
    balanceWorkload: "+balanceWorkload(specialists: ClinicalSpecialist[]): ClinicalSpecialist[]"
    matchExpertise: "+matchExpertise(specialists: ClinicalSpecialist[], programType: ProgramType): ClinicalSpecialist[]"

    note: "Assignment business logic\nPure domain service"
  }
}

# Domain Events (Business State Changes)
domain_events: Domain Events {
  EnrollmentInitiatedEvent: EnrollmentInitiatedEvent {
    shape: class

    enrollmentId: "+enrollmentId: EnrollmentId"
    patientId: "+patientId: PatientId"
    programType: "+programType: ProgramType"
    occurredOn: "+occurredOn: Date"

    note: "New enrollment started"
  }

  QualificationCompletedEvent: QualificationCompletedEvent {
    shape: class

    enrollmentId: "+enrollmentId: EnrollmentId"
    isQualified: "+isQualified: boolean"
    reasoning: "+reasoning: string"
    assessedBy: "+assessedBy: UserId"
    occurredOn: "+occurredOn: Date"

    note: "Qualification assessment done"
  }

  PatientStatusChangedEvent: PatientStatusChangedEvent {
    shape: class

    enrollmentId: "+enrollmentId: EnrollmentId"
    previousStatus: "+previousStatus: EnrollmentStatusType"
    newStatus: "+newStatus: EnrollmentStatusType"
    reason: "+reason: string"
    changedBy: "+changedBy: UserId"
    occurredOn: "+occurredOn: Date"

    note: "Status transition occurred"
  }
}

# Entity Relationships
entities.Patient -> value_objects.PatientDemographics: "contains"
entities.ProgramEnrollment -> entities.Patient: "aggregates"
entities.ProgramEnrollment -> entities.AuditTrailEntry: "contains collection"
entities.ProgramEnrollment -> value_objects.EnrollmentStatus: "has current"
entities.ProgramEnrollment -> value_objects.EnrollmentProgress: "calculates"
entities.NIVProgramEnrollment -> entities.ProgramEnrollment: "extends"

# Factory Dependencies (Enhanced)
factories.NIVProgramEnrollmentFactory -> entities.NIVProgramEnrollment: "creates"
factories.NIVProgramEnrollmentFactory -> domain_services.NIVEligibilityService: "uses for validation"
factories.NIVProgramEnrollmentFactory -> domain_services.SpecialistAssignmentService: "uses for assignment"
factories.PatientFactory -> entities.Patient: "creates"
factories.QualificationAssessmentFactory -> entities.NIVProgramEnrollment: "creates assessments for"

# Domain Service Dependencies
domain_services.NIVEligibilityService -> entities.Patient: "operates on"
domain_services.SpecialistAssignmentService -> entities.ProgramEnrollment: "assigns to"

# Domain Events Published By
entities.ProgramEnrollment -> domain_events.EnrollmentInitiatedEvent: "publishes"
entities.NIVProgramEnrollment -> domain_events.QualificationCompletedEvent: "publishes"
entities.ProgramEnrollment -> domain_events.PatientStatusChangedEvent: "publishes"
